# CSRF (크로스 사이트 요청 위조)

개인 공부용으로 참고하기 위해서 버그바운티 클럽의 Pentest Gym에서 퍼온 사진과 글을 참고하여 정리한 문서입니다. 

| 출처 : https://www.bugbountyclub.com/pentestgym/view/47

# CSRF란?
CSRF(Cross-Site Request Forgery, 크로스 사이트 요청위조, XSRF)는 사용자가 원하지 않는 행위, 정확히 말해 공격자가 의도한 행위를 웹 애플리케이션에 요청하게 하는 취약점이다. 클라이언트 웹 취약점 중 하나이며, 세션 라이딩(Session Riding)이라고도 불린다. 공격자는 이메일이나 SNS, 채팅 메시지 등 피싱 공격을 통해 사용자의 웹 브라우저가 공격자에 의해 작성된 악의적인 URL을 방문하도록 유도하는 사회공학 기법을 활용한다. 악의적인 URL 방문한 사용자의 웹 브라우저는 CSRF에 취약한 웹 애플리케이션에 사용자의 의자와 상관없이 공격자에게 이득이 되는 요청을 보내게 된다

# CSRF의 동작 원리
CSRF는 HTTP 프로토콜의 Stateless와 Connectionless 특성을 이용한 취약점이다. 이 두가지 특성으로 인해 웹은 사용자 식별과 상태 추적을 위해 쿠키와 세션을 주로 사용한다. CSRF는 바로 이 세션과 쿠키를 이용해 사용자를 인증하고 세션을 추적하는 웹 애플리케이션에서 발생하는 취약점이다

세션과 쿠키를 인증 수단으로 사용하는 웹 애플리케이션에서는 사용자가 로그인한 후 부터 별도의 인증 과정이 없더오 요청을 보낸 사용자가 누구인지 식별할 수 있고, 로그인된 사용자의 상태를 유지할 수 있다. 이는 최초 로그인시 서버에 의해 발급(Set-Cookie 응답 헤더를 통해 발급)된 세션 토큰을 후속 요청을 보낼때 마다 자동으로 Cookie 요청 헤더에 추가하여 요청하는 웹 브라우저의 동작 방식 때문이다. Cookie 헤더에 세션 토큰이 포함된 요청을 받은 웹 애플리케이션은 서버에 보관중이 사용자별 세션 토큰과 사용자의 웹 브라우저에 의해 전송된 쿠키 안의 토큰을 비교하여 사용자를 판단하게 된다.
![](https://www.bugbountyclub.com/uploads/images/training/1633484954.png)

문제는 여기서 발생한다. 요청을 보낸 실제 주체가 누구인지? 쿠키를 통해 전송된 토큰을 통해 판단한다. 웹 애플리케이션 입장에선 사용자의 토큰이 사용된 요청은 그저 사용자의 요청일 뿐 공격자가 세션 토큰을 이용해 악의적 요청을 보내도 정상적인 사용자와 따로 구별해낼 방도가 없다는 뜻이다.

아래의 그림은 사용자 계정을 탈취하는 과정을 그린것이다.
![](https://www.bugbountyclub.com/uploads/images/training/1633486020.png)

웹 애플리케이션이 CSRF 공격에 취약하기 위해서는 아래의 세가지 조건이 충족되어야한다
1. 권한이 요구되는 민감한 기능이어야한다.
2. HTTP 쿠키만 사용해 사용자 세션을 추적해야 한다
3. 요청에 사용되는 매개변수를 공격자가 알 수 있어야한다

반면, CSRF 공격은 로그인된 사용자의 세션 토큰을 이용한다는 점으로 인해 한계가 발생하기도 한다. 바로 공격자가 웹 애플리케이션에서 할 수 있는 행위가 피해자의 권한에 종속된다는 점이다. 따라서 피해자의 계정과 사용 환경에 한해 영향을 끼칠 수 있다는 것이다.

# CSRF의 영향
CSRF의 영향은 웹 애플리케이션에서 피해자에게 주어진 권한이나 사용할 수 있는 기능에 따라 다르다. 위에서 본 사용자 계정을 탈취하는 과정에서 피해자의 이메일 주소를 변경하고 패스워드 초기화 기능을 통해 계정 탈취까지 이어질 수 있다. 또한 피해자가 관리자 권한을 가지고 있다면 공격자는 민감한 데이터 유출, 데이터베이스 수정 및 삭제 등 애플리케이션 전반적으로 장악하고 손상 시킬 수 있다.

# CSRF 예방

## Referer 요청 헤더 검증
요청에 포함된 Referer 요청 헤더의 값을 검증하는 방법이다. Referer 요청 헤더의 값이 자신과 동일한 도메인이라면 요청을 수행하고, 다른 도메인이라면 공격으로 간주하고 요청을 차단하는 방법이다. 안전하게 구현한다면 CSRF 공격에 대한 방어 수단이 될 수 있지만 오로지 이 방법으로만 의존해서 CSRF 공격을 방어한다는건 무리가 있다.

## Anti-CSRF 토큰
사용자의 세션을 추적하기 위해 기존의 세션 토큰 이외의 추가적인 임의의 토큰을 사용하는 방법이다. 이 토큰은 사용자의 웹 브라우저와 서버만 알고 있고, 주로 사용자가 어떤 웹 페이지를 로딩할 때 아래와 같이 숨겨진 폼 필드에 저장되었다가 제출할때 서버로 다시 전송된다.
```
<input type="hidden" id="security_token" name="security_token" value="토큰값">
```
제출된 토큰을 받은 서버는 해당 사용자의 세션 변수에 저장해두었던 토큰과 비교하여 일치할 경우에 요청을 수행한다. 올바르게 구현한 경우 CSRF 공격을 예방할 수 있고 많은 웹 애플리케이션 개발 프레임워크에서 CSRF를 방어하기 위해서 제공된다.

## 이중 제출(Double Submit) 쿠키
웹 브라우저의 SOP(Same Origin Policy, 동일 출처 정책)에 의해 다른 도메인의 응답에 접근할 수 없는 점을 이용한 방법이다.  SOP에 의해 공격자의 웹 사이트에서는 취약한 웹 사이트에서 발급하는 쿠키를 읽거나 변경할 수 없으므로 공격자는 CSRF 공격에 필요한 모든 매개변수의 값을 알지 못하고 CSRF 취약 조건을 충족시킬 수 없게 된다. 이중 제출 쿠키는 Anti-CSRF 토큰과 달리 서버 세션에 저장하지 않고 쿠키로 클라이언트에게 발급하는 방식이다. 따라서 클라이언트는 Set-Cookie 헤더를 통해 두개의 쿠키를 발급받는다. 하나는 사용자 세션토큰, 하나는 CSRF 공격을 방어하기 위한 Anti-CSRF 토큰이다

## SamaSite 쿠키
쿠키는 보안을 강화할 수 있는 플래그가 된다. SameSite 플래그는 요청이 발생한 출처가 동일한 경우에만 자동으로 세션 토큰을 추가하도록 제한한다
즉 aaa.com/edit_profile.php로 요청을 할 경우 aaa.com 웹 사이트에서 시작된 요청에만 세션 토큰이 추가되고, attack.com과 같이 다른 도메인에서 발생한 요청 같은 경우에는 사용자의 세션 토큰이 포한되지 않는 것이다. 서버에서 Set-Cookie 헤더를 통해 아래와 같이 설정된다
```
Set-Cookie: Cookie_name=Cookie_value; SameSite=지시자(Direcrive)
```
지시자의 종류
- None : 별도의 검증없이 쿠키를 추가한다, 별도 설정이 없을 경우 기본값이다. 하지만 요즘 크롬80 이상 부터는 Lax를 기본값으로 사용한다
- Lax : `<a href=....`,`<form method="GET...>`과 같이 핸들링이 불가능한 GET 메소드를 통한 요청에만 쿠키를 자동으로 추가하고 그외 요청에는 쿠키를 보내지 않는다.
- Strict : 가장 강한 설정으로 다른 도메인에서 시작된 모든 요청은 쿠키를 추가하지 않는다

## Captcha 사용
요청마다 갱신되는 캡차 검증 또한 공격자가 알 수 없는 새로운 매개 변수를 추가해 CSRF 공격을 차단한다

# CSRF 테스트 방법

## 1. 웹 애플리케이션 기능 점검
테스트 중인 웹 애플리케이션 기능을 살펴보는데, 만약 회원가입 및 로그인 기능이 있다면 테스트 계정을 만들고 로그인하여 인증된 계정으로 기능을 살펴본다
아래 3가지를 모두 충족하는 요청을 찾는다
- 권한이 요구되는 기능
- 쿠키에만 의존하여 사용자 세션을 추적하는 기능
- 모든 매개변수를 사전에 알 수 있는 요청

## 2. 공격 코드 작성
공격에 사용할 코드를 작성하는데 요청에 따라 다른 방법을 이용해야한다

### GET 요청
1. 엔드포인트(취약한 진입점)에 src 속성으로 갖는 `<img>` 태그를 사용하여 HTML 페이지를 작성
2. 피해자가 웹 페이지 방문 시 `<img>` 태그는 이미지를 로드하기 위해 지정된 URL로 접속을 시도하게 됨
3. URL 주소는 공격자가 의도한 행위를 하는 URL인데, 실제 이미지를 가지고 오는지 악의적인 요청인지 구분할 수 없다
4. 웹 서버는 이미지든 아니든 정상적으로 전송되고, 의도치 않은 요청을 성공하게 된다
```
<img src="http://vulnerable-web.com/edit_profille.php?param_1=som_value&param_2=some_value"/>
```

### POST 요청
취약한 췝 애플리케이션의 엔드포인트로 요청을 전송하고, 요청에 사용되는 모든 매개변수와 값이 숨겨진 필드로 포함된 폼을 만들어야한다
```
<form action="http://vulnerable-web.com/edit_profile.php" method="POST">
	<input type="hidden" name="param_1" value="some_value">
	<input type="hidden" name="param_2" value="some_value">
 	...생략...
	<input type="hidden" name="parameter_N" value="some_value">
</form>
<script>
	document.forms[0].submit(); // 로딩될 때 자동으로 폼이 제출되도록 구성함.
</script>
```

## 3. 취약 여부 테스트
실제 공격 상황에서는 이메일, SNS 등을 통해 피해자가 공격 코드가 포함된 외부 웹 페이지를 방문하도록 유도해야하고, 피해자가 공격 코드가 포함된 웹사이트를 방문하는 순간에 동일한 웹 브라우저 환경에서 취약한 애플리케이션에 로그인되어 있도록 추가적인 작업이 필요할 수 있다.
만약 공격자의 웹 애플리케이션 내부에 공격자의 공격 코드를 주입할 수 있는 HTML 인젝션이나 XSS 취약점이 있는 엔드포인트를 발견했다면 해당 취약점과 CSRF를 연계할 수 있다. 이 경우 HTML 인젝션이나 XSS 취약점을 통해 웹 애플리케이션 내부의 다른 웹 페이지에 주입된 악성 링크를 통해 요청이 시작되므로 웹 브라우저의 SOP에 위배되지 않는다. 이는 크로스 도메인 요청시에만 CSRF 공격을 차단하는 SamSite 쿠키 등의 방어 수단은 더이상 효과가 없다는 것을 의미한다. 또한 피해자는 이미 로그인을 통해 인증된 사용자일 확률이 높으므로 공격 효과와 성공율을 향상시킬 수 있는 방법입니다.